# Topic: Symmetric Ciphers. Stream Ciphers. Block Ciphers.

### Course: Cryptography & Security
### Author: Rafaela Cerlat

----

## Theory
&nbsp;&nbsp; Asymmetric encryption is a type of encryption that uses two separates yet mathematically related keys to encrypt and decrypt data. The public key encrypts data while its corresponding private key decrypts it. This is why it’s also known as public key encryption, public key cryptography, and asymmetric key encryption.
  
&nbsp;&nbsp; The public key is open to everyone. Anyone can access it and encrypt data with it. However, once encrypted, that data can only be unlocked by using the corresponding private key. As you can imagine, the private key must be kept secret to keep it from becoming compromised. So, only the authorized person, server, machine, or instrument has access to the private key.
  
&nbsp;&nbsp; Asymmetric encryption is a way for you to verify third parties that you’ve never met via public channels that are insecure. Unlike traditional (symmetric) encryption methods, which rely on one key to encrypt and decrypt data, asymmetric key encryption uses two separate keys to perform these functions. This is why public key encryption is considered a critical element in the foundation of internet security.

&nbsp;&nbsp; The RSA algorithm  is a public-key cryptosystem that is widely used for secure data transmission. The algorithm is named after those who invented it in 1978: Ron Rivest, Adi Shamir, and Leonard Adleman. An RSA user creates and publishes a public key based on two large prime numbers, along with an auxiliary value. The prime numbers are kept secret. Messages can be encrypted by anyone, via the public key, but can only be decoded by someone who knows the prime numbers. The security of RSA relies on the practical difficulty of factoring the product of two large prime numbers, the "factoring problem". It is a relatively slow algorithm. Because of this, it is not commonly used to directly encrypt user data. More often, RSA is used to transmit shared keys for symmetric-key cryptography, which are then used for bulk encryption–decryption.

----
## Implementation
RSA involves a public key and a private key. The public key can be known by everyone and is used for encrypting messages. The intention is that messages encrypted with the public key can only be decrypted in a reasonable amount of time by using the private key. The public key is represented by the integers n and e, and the private key by the integer d (although n is also used during the decryption process, so it might be considered to be a part of the private key too). 
  
  Here the RSA algorithm involves three steps: key generation, encryption, and decryption.

### Generating the keys
1. The keys are generated by selecting 2 prime numbers. In this implementation we just need a number n as input, which will be used to generate the prime numbers 
<em><strong>x</strong></em> and <em><strong>y</strong></em>. 
Those numbers need to be large so that they will be difficult for someone to figure out.
  
    For that we have the constructor:
    ```
    private final int number;

    public RSA(int number) {
        this.number = number;
        generateKey();
    }
    ```
    And the following lines from the method generateKey():
    ```
    BigInteger x = BigInteger.probablePrime(number/2, new SecureRandom());
    BigInteger y = BigInteger.probablePrime(number/2, new SecureRandom());
    ```
2. The modulus <em><strong>n</strong></em> is the product of <em><strong>x</strong></em> and <em><strong>y</strong></em>.
    ```
    private BigInteger n;
    
    n = x.multiply(y);
    ```
3. There's the Carmichael's totient function computed by the following formula: <em><strong>ϕ(n)=(x−1)(y−1)</strong></em>.
    ```
    BigInteger totient = (x.subtract(BigInteger.ONE)).multiply(y.subtract(BigInteger.ONE));
    ```
4. Finding the integer <em><strong>e</strong></em> such that <em><strong>1 < e < ϕ(n)</strong></em> and <em><strong>gcd(e, ϕ(n)) = 1</strong></em>; that is, e and ϕ(n) are coprime.
    ```
    private BigInteger e;
    
    e = coprime(totient, number);
    
      private static BigInteger coprime(BigInteger totient, int number){
        Random random = ThreadLocalRandom.current();
        BigInteger e;
        do {
            e = new BigInteger(number, random);
        } while (e.min(totient).equals(totient) & !gcd(totient, e).equals(BigInteger.ONE));

        return e;
      }
    ```
    The pair of numbers <em><strong>(n,e)</strong></em> makes up the public key.
5. Finding <em><strong>d</strong></em> as $d ≡ e^−1 (mod λ(n))$ ; that is, <em><strong>d</strong></em> is the modular multiplicative inverse of <em><strong>e mod ϕ(n)</strong></em>. 
  This <em><strong>d</strong></em> can be found using the extended euclidean algorithm. 
    ```
    private BigInteger d;
    
    d = extendedEuclidean(e, totient)[1];
    
     private static BigInteger[] extendedEuclidean(BigInteger a, BigInteger b){
        if(b.equals(BigInteger.ZERO))
            return new BigInteger[]{a, BigInteger.ONE, BigInteger.ZERO};
        BigInteger[] values = extendedEuclidean(b, a.mod(b));
        BigInteger x = values[0];
        BigInteger y = values[2];
        BigInteger z =  values[1].subtract(a.divide(b).multiply(y));
        return new BigInteger[]{x, y, z};
     }
    ```
  The pair of numbers <em><strong>(n,d)</strong></em> makes up the private key.

### Encryption
  Given a plaintext <em><strong>P</strong></em>, represented as a number, the ciphertext <em><strong>C</strong></em> is calculated as: 
  $C = P^e mod n$
  ```
   @Override
    public String encrypt(String message) {
        BigInteger encrypted = new BigInteger(message.getBytes()).modPow(e,n);
        return  Base64.getEncoder().encodeToString(encrypted.toByteArray()) ;
    }
   ```
### Decryption
  Using the private key <em><strong>(n,d)</strong></em>, the plaintext can be found using:
  $P = C^d mod n$
  ```
   @Override
    public String decrypt(String encryptedMessage) {
        BigInteger decrypted = new BigInteger(Base64.getDecoder().decode(encryptedMessage)).modPow(d,n);
        return new String(decrypted.toByteArray());
    }
   ```
  
  
