# Topic: Hash functions and Digital Signatures. 

### Course: Cryptography & Security
### Author: Rafaela Cerlat

----

## Theory
A **digital signature** is based on asymmetric cryptography; it is used to validate that a message is coming from an authentic source and has not changed during transit. Each user has two mathematically linked keys: a private key and a public key. The public key is shared with the receiver, but the private key is kept private.
A message encrypted with a private key can only be decrypted using the corresponding public key.

![image](https://user-images.githubusercontent.com/41265306/206059958-23d09d82-38e5-40d9-a9e1-f0f313f05845.png)

Technically, the digital signature is an encrypted hash of a message or document. It means that a digital signature generates a hash from a message. After that, the generated hash is encrypted with a private key. We can use SHA and RSA hashing algorithms for the same.

When we send a message, the encrypted hash and corresponding key also send with the message that classified as a message with the digital signature.


#### 1) Generating a digital signature
A digital signature relies on hashing and public key cryptography. When you sign data, you hash the data and encrypt the results with your private key. The encrypted hash value is called a digital signature.

If you change the original data, a different digital signature will be generated.

#### 2) Verifying a digital signature
Verifying a digital signature is the opposite of signing data. Verifying a signature will tell you if the signed data has changed or not. When a digital signature is verified, the signature is decrypted using the public key to produce the original hash value.
The data that was signed is hashed. 

If the two hash values match, then the signature has been verified, or in other words it means that the message did not change in transit.

## Objectives:
1. Get familiar with the hashing techniques/algorithms.
2. Use an appropriate hashing algorithms to store passwords in a local DB.
    1. You can use already implemented algortihms from libraries provided for your language.
    2. The DB choise is up to you, but it can be something simple, like an in memory one.
3. Use an asymmetric cipher to implement a digital signature process for a user message.
    1. Take the user input message.
    2. Preprocess the message, if needed.
    3. Get a digest of it via hashing.
    4. Encrypt it with the chosen cipher.
    5. Perform a digital signature check by comparing the hash of the message with the decrypted one.


## Implementation 
We have the User class, with the sensitive data, such as password:
```
@Data
@AllArgsConstructor
public class User{
    private Long id;
    private String username;
    private String password;
}
```
#### [Database](https://github.com/rafaelacerlat/CS-labs/blob/master/src/main/java/Hashing/Repository.java)
The in-memory database, represented as a singleton class Repository, that stored user info in a HashMap, each password is linked to an user id.

With the save() method new users are added to the repository, and with getById() - user's id is used to extract their password:
```
public void save(Long userId, String password){
    passwords.put(userId,password);
}

public String getById(Long userId){
    String password = passwords.get(userId);
        if (password != null){
            return password;
        }else{
            throw new NullPointerException("There is no such user!");
        }
}
```
#### [Digital Signature](https://github.com/rafaelacerlat/CS-labs/blob/master/src/main/java/Hashing/DigitalSignature.java)
To create a digital signature, the SHA-256 cryptographic hash (sometimes called 'digest') is used to provide a one-way hash of the data to be signed. The hash is a fixed-length string of letters and numbers generated by the algorithm.
DatatypeConverter is used to convert the hash from an array of bytes into a string.
```
  public String hash(String message){
        try{
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            byte[] digest = md.digest(message.getBytes());
            String hashedMessage = DatatypeConverter.printHexBinary(digest);
            return hashedMessage;

        } catch (Exception e) {
            throw new RuntimeException("Could not prepare data for hashing!");
        }
    }
```
After that there's the sign() method which just encrypts the hash using RSA cipher. 
```
    public String sign(String message){
        try{
            return rsaEncryption.encrypt(hash(message));
        } catch (Exception e) {
            throw new RuntimeException("Could not generate the digital signature!");
        }
    }
```
The last step is to verify if the signed data has changed or not. For that the digital signature optained from sign() is decrypted with the same RSA cipher.
```
  public boolean check(String password, String digitalSignature){
        String decryptedPassword = rsaEncryption.decrypt(digitalSignature);
        return password.equals(decryptedPassword);
    }
```
#### [Test](https://github.com/rafaelacerlat/CS-labs/blob/master/src/test/java/Ciphers/Hashing/DigitalSignatureTest.java)
As a user's input message I used the user's password. The hashed password stored in the database was used to compare with the digital signature obtained from the initial plaintext password.
```
        DigitalSignature digitalSignature = new DigitalSignature();
        
        User user = new User(1L,"rafaelacerlat", "secure123");
        passwordRepository.save(user.getId(), digitalSignature.hash(user.getPassword()));

        
        String userHashedPassword = passwordRepository.getById(user.getId());

        
        String userDigitalSignature = digitalSignature.sign(user.getPassword());

        
        boolean valid = digitalSignature.check(userHashedPassword, userDigitalSignature);

        Assertions.assertTrue(valid);
 ```





